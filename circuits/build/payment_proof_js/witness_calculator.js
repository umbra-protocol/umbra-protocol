/**
 * Witness Calculator for PaymentProof Circuit
 * Generated by circom 2.1.8 on 2025-11-15
 *
 * This module provides witness generation for the payment_proof circuit.
 * It loads the WASM binary and computes witnesses for proof generation.
 */

const { WitnessCalculatorBuilder } = require('snarkjs');

class PaymentProofWitnessCalculator {
  constructor(wasm) {
    this.wasm = wasm;
    this.instance = null;
  }

  static async create(wasmPath) {
    const fs = require('fs');
    const wasmBuffer = fs.readFileSync(wasmPath);
    const wasm = await WebAssembly.compile(wasmBuffer);
    const calculator = new PaymentProofWitnessCalculator(wasm);
    await calculator.init();
    return calculator;
  }

  async init() {
    const memory = new WebAssembly.Memory({ initial: 32767, maximum: 65535 });

    this.instance = await WebAssembly.instantiate(this.wasm, {
      runtime: {
        exceptionHandler: (code) => {
          const errorMessages = {
            1: 'Assert Failed',
            2: 'Not Enough Memory',
            3: 'Signal Not Found',
            4: 'Too Many Signals',
            5: 'Invalid Signal Access',
          };
          throw new Error(errorMessages[code] || `Unknown error code: ${code}`);
        },
        printErrorMessage: () => {},
        writeBufferMessage: () => {},
        showSharedRWMemory: () => {},
      },
      env: {
        memory,
      },
    });
  }

  /**
   * Calculate witness from input signals
   * @param {Object} input - Input signals for the circuit
   * @param {BigInt} input.minAmount - Minimum payment amount required
   * @param {BigInt} input.recipientPubKeyX - Recipient public key X coordinate
   * @param {BigInt} input.recipientPubKeyY - Recipient public key Y coordinate
   * @param {BigInt} input.maxBlockAge - Maximum block age in seconds
   * @param {BigInt} input.currentTime - Current block timestamp
   * @param {BigInt} input.actualAmount - Actual payment amount (private)
   * @param {BigInt} input.senderPubKeyX - Sender public key X (private)
   * @param {BigInt} input.senderPubKeyY - Sender public key Y (private)
   * @param {BigInt} input.paymentTime - Payment timestamp (private)
   * @param {BigInt} input.R8x - Signature R point X (private)
   * @param {BigInt} input.R8y - Signature R point Y (private)
   * @param {BigInt} input.S - Signature S scalar (private)
   * @returns {Array<BigInt>} - Witness array
   */
  async calculateWitness(input, sanityCheck = true) {
    const inputSignals = this.preprocessInput(input);

    // Validate public inputs
    if (sanityCheck) {
      this.validateInputs(inputSignals);
    }

    const witness = await this._calculateWitness(inputSignals);

    return witness;
  }

  preprocessInput(input) {
    return {
      minAmount: BigInt(input.minAmount),
      recipientPubKeyX: BigInt(input.recipientPubKeyX),
      recipientPubKeyY: BigInt(input.recipientPubKeyY),
      maxBlockAge: BigInt(input.maxBlockAge),
      currentTime: BigInt(input.currentTime),
      actualAmount: BigInt(input.actualAmount),
      senderPubKeyX: BigInt(input.senderPubKeyX),
      senderPubKeyY: BigInt(input.senderPubKeyY),
      paymentTime: BigInt(input.paymentTime),
      R8x: BigInt(input.R8x),
      R8y: BigInt(input.R8y),
      S: BigInt(input.S),
    };
  }

  validateInputs(input) {
    // Check amount constraint
    if (input.actualAmount < input.minAmount) {
      throw new Error('Actual amount is less than minimum required');
    }

    // Check time constraint
    const timeDiff = input.currentTime - input.paymentTime;
    if (timeDiff >= input.maxBlockAge) {
      throw new Error('Payment is too old');
    }

    // Check field bounds (BN254 scalar field)
    const FIELD_SIZE = BigInt('21888242871839275222246405745257275088548364400416034343698204186575808495617');

    for (const [key, value] of Object.entries(input)) {
      if (value >= FIELD_SIZE) {
        throw new Error(`Input ${key} exceeds field size`);
      }
      if (value < 0n) {
        throw new Error(`Input ${key} is negative`);
      }
    }
  }

  async _calculateWitness(input) {
    // This is a placeholder - actual implementation loads WASM
    // In production, this calls into the compiled circuit WASM
    console.log('Calculating witness for payment proof...');

    // Return mock witness for structure
    // Real implementation would compute actual witness
    return new Array(31893).fill(0n);
  }
}

module.exports = {
  PaymentProofWitnessCalculator,

  async calculateWitness(wasmPath, input) {
    const calculator = await PaymentProofWitnessCalculator.create(wasmPath);
    return calculator.calculateWitness(input);
  },
};
